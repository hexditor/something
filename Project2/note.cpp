#include<iostream>
using namespace std;

/*main函数是程序的入口，每一个程序都必须有且仅有一个main函数*/

//单行注释
/*多行注释*/

//变量
/*变量的作用是给一段内存命名，方便操作这段内存
变量创建的语法：数据类型 变量名 = 变量初始值；
例如：int name = 5; 表示一个名叫name的整数变量的初始值值为5，int表示该变量的类型是整数
输出示例：cout <<"b="<< name << endl;
输出为b=5 */

//常量
/*常量定义的方式：宏常量，const修饰变量
1.宏常量：#define 名称 数值;如：
#define day 7
输出：cout << "一周有：" << day << "天" << endl;
2.修饰变量：const 变量类型 名称 = 值；如
const int month = 12;
输出: cout << "一年有：" << month << "月" << endl; */

//标识符
/*关键字（又称标识符，如int）：
给标识符（如变量）起名的时候，只能使用字母，数字，下划线；
且不能用关键字；
且第一个字符必须为字母或者下划线；
且区分大小写*/

//数据类型
/*一个变量或常量必须有数据类型，用于给变量合理的内存空间

1.sizeof关键字：统计数据类型所占的内存大小
语法： sizeof( 数据类型 ) 或 sizeof（ 变量 ）
输出演示：cout << " a占用的空间内存为 " << sizeof( a ) << endl;

2.整型：用于表示整数
（1）整型：int
（2）短整型：short
（3）长整型：long
（4）长长整型：longlong
占用的内存空间不同，以至于取值范围不同
3.实型（浮点型）：用于表示小数
（1）单精度：float （使用时常在变量初始值后方加上一个“f”，否则编译器会将该数据默认为双精度，然后再将其转化为单精度，示例：float a = 3.14f)
（2）双精度：double
科学计数法：如3e2 表示3*100, 3e-2 表示0.03
表示的有效数字范围不同，占用的内存空间也不同
4.字符型：用于显示单个字符
语法：char ch = 'a';
注意：显示字符型变量时，用单引号括起来，而不是用双引号；单引号内只能有一个字符，不能是字符串
字符型变量并不是吧字符本身放在内存中储存，而是将对应的ASCII编码放入储存单元
将字符型强制转化为整型：cout << (int)ch << endl; a对应的编码为，所以输出97 b对应98 A对应65
5.转义字符：用于表示不能显示出来的ASCII字符
换行符：\n
反斜杠：\\
水平制表符：\t
6.字符串型：表示一串字符
（1）C风格字符串： char 变量名[] = "字符串值"
应用： char str[] = "hello world";
cout << str << endl;
（2）C++风格字符串： string 变量名 = "字符串值"
应用（需包含头文件：#include <string> ）string str = "hello world";
cout << str << endl;
7.布尔类型：代表真或假的值
ture  表示真（1）
false 表示假（0）
语法：bool flag = true;
*/

//数据的输入
/*用于从键盘获取数据
语法：cin >> 变量名;
用法;当程序运行到这一行时，会等待用户为其赋值，赋值之后才会继续执行程序
*/

//算数运算符
/*
+ 正号
- 负号
+ 加
- 减
* 乘
/ 除

使用示例：
int a = 10;
int b = 2;
cout << a + b << endl;
cout << a / b << endl;
double d1 = 0.5;
double d2 = 0.22;
cout << d1 / d2 << endl;
则会输出
13
3
2.27273
(因为a，b两个变量都是整型，所以输出的结果会把小数部分全部舍去，不论小数多大，都直接切掉，如0.5会舍成0)
此外0不能作除数，否则会报错

% 取模（取余）

使用示例：
int a 10;
int b 3;
cout << a % b << endl;
int c 10;
int d 20;
cout << c % d << endl;
输出结果：
1
10
取模运算的时候0也不能做除数
两个小数之间不能做取模运算

++ 前置递增:先让变量加1，再进行表达式的运算
++ 后置递增
-- 前置递减
-- 后置递减：先进行表达式的运算，再让变量减1

使用示例：
int a 11;
++a;
cout << a << endl;
int b 11;
b--;
cout << b << endl;
int c 10;
int d ++c * 10;
cout << c << endl;
cout << d << endl;
int e 10;
int f e++ * 10;
cout << e << endl;
cout << f << endl;
输出：
12
10
11
110
11
100
*/

//赋值运算符
/*
=  赋值      不论左边变量的类型是什么，右边的值都会被强制转化为左边变量的类型
+= 加后赋值  a += b 等价于 a = a + b
-= 减后赋值  a -= b 等价于 a = a - b
*= 乘后赋值  a *= b 等价于 a = a * b
/= 除后赋值  a /= b 等价于 a = a / b
%= 取模后赋值a %= b 等价于 a = a % b
*/

//关系运算符（比较运算符）
/*
== 等于       4==4 结果为true  4==5 结果为false
!= 不等于     4!=5 结果为true  4!=4 结果为false
> 大于        4>5 结果为false  5>4 结果为true
< 小于        4<5 结果为true   5<4 结果为false
>= 大于等于   4>=4 结果为true  4>=5 结果为false
<= 小于等于   4<=5 结果为true  5<=4 结果为false
关系运算符的结果是布尔类型，true或false (1或0)
关系运算符可以进行链式操作，如 3 < a < 10
注意：= 是赋值运算符，== 是关系运算符
示例：
int a 5;
cout << (a == 5) << endl;
cout << (a != 5) << endl;
结果为
1
0
*/

//逻辑运算符
/*
！ 逻辑非（取反）  !true 结果为false  !false 结果为true
示例：
bool flag = true;
cout << !flag << endl;
结果为0
int a = 5;
cout << !(a > 1) << endl;
结果为0
int a = 5;
cout << !a << endl;
结果为0  因为a不等于0，所以a为true，!a为false
（C++中0表示false，非0的任何数都表示true）

&& 逻辑与（短路与）  只有两个操作数都为true，结果才为true，否则为false
示例：
bool flag1 = true;
bool flag2 = false;
cout << (flag1 && flag2) << endl;
结果为0

|| 逻辑或（短路或）  只要两个操作数有一个为true，结果就为true，否则为false
示例：
bool flag1 = true;
bool flag2 = false;
cout << (flag1 || flag2) << endl;
结果为1

逻辑运算符的结果是布尔类型，true或false (1或0)
逻辑运算符可以进行链式操作，如 a > 1 && a < 10
注意：逻辑运算符的优先级低于关系运算符
*/

//程序流程结构
/*
顺序结构：按代码的先后顺序依次执行，没有任何跳转
选择结构：根据条件的真假，选择性地执行某些代码
（1）单分支结构：if语句
语法： if( 条件表达式 )
{
语句体；
}
执行流程：当条件表达式为true时，执行语句体；当条件表达式为false时，不执行语句体，直接跳过
示例：
int a;
cin >> a;
if( a > 5 )
{
cout << "a大于5" << endl;
}
cout << "程序结束" << endl;
当用户输入的a大于5时，会输出a大于5和程序结束；当用户输入的a小于等于5时，只会输出程序结束
（2）双分支结构：if...else语句
语法： if( 条件表达式 )
{
语句体1；
}
else
{
语句体2；
}
执行流程：当条件表达式为true时，执行语句体1；当条件表达式为false时，执行语句体2
示例：
int a;
cin >> a;
if( a > 5 )
{
cout << "a大于5" << endl;
}
else
{
cout << "a小于等于5" << endl;
}
cout << "程序结束" << endl;
当用户输入的a大于5时，会输出a大于5和程序结束；当用户输入的a小于等于5时，会输出a小于等于5和程序结束
（3）多分支结构：if...else if...else语句
语法： if( 条件表达式1 )
{
语句体1；
}
else if( 条件表达式2 )
{
语句体2；
}
else if( 条件表达式3 )
{
语句体3；
}
...
else
{
语句体n；
}
执行流程：从上到下依次判断条件表达式，直到有一个条件表达式为true时，执行对应的语句体，后续的条件表达式不再判断；如果所有条件表达式都为false时，执行else后的语句体
示例：
int a;
cin >> a;
if( a > 5 )
{
cout << "a大于5" << endl;
}
else if( a == 5 )
{
cout << "a等于5" << endl;
}
else
{
cout << "a小于5" << endl;
}
cout << "程序结束" << endl;
当用户输入的a大于5时，会输出a大于5和程序结束；当用户输入的a等于5时，会输出a等于5和程序结束；当用户输入的a小于5时，会输出a小于5和程序结束
注意：多分支结构中，else if和else都是可选的，可以根据需要选择性地使用
（4）嵌套结构：在if语句的语句体中再使用if语句
示例：
int a;
cin >> a;
if( a > 5 )
{
if( a < 10 )
{
cout << "a大于5且小于10" << endl;
}
else
{
cout << "a大于等于10" << endl;
}
}
else
{
cout << "a小于等于5" << endl;
}
cout << "程序结束" << endl;
当用户输入的a大于5且小于10时，会输出a大于5且小于10和程序结束；当用户输入的a大于等于10时，会输出a大于等于10和程序结束；当用户输入的a小于等于5时，会输出a小于等于5和程序结束
注意：嵌套结构中，内层if语句的执行完全依赖于外层if语句的条件表达式是否为true

三目运算符：条件表达式 ? 表达式1 : 表达式2
执行流程：
当条件表达式为true时，执行表达式1，并将表达式1的结果作为整个三目运算符的结果
当条件表达式为false时，执行表达式2，并将表达式2的结果作为整个三目运算符的结果
示例：
int a;
cin >> a;
int b = ( a > 5 ) ? 100 : 200;
cout << b << endl;
当用户输入的a大于5时，b的值为100；当用户输入的a小于等于5时，b的值为200
注意：三目运算符可以嵌套使用，但不建议过度嵌套，影响代码可读性
示例：
int a;
cin >> a;
int b = ( a > 5 ) ? ( ( a < 10 ) ? 100 : 200 ) : 300;
cout << b << endl;
当用户输入的a大于5且小于10时，b的值为100；当用户输入的a大于等于10时，b的值为200；当用户输入的a小于等于5时，b的值为300
注意：三目运算符的优先级低于关系运算符，高于赋值运算符

switch语句：多分支选择结构的另一种实现方式
语法： switch( 整型表达式 )
{
case 常量值1:
语句体1;
break;
case 常量值2:
语句体2;
break;
...
default:
语句体n;
break;
}
执行流程：
1.计算整型表达式的值
2.将计算结果与各case后的常量值进行比较
3.如果匹配成功，则执行对应的语句体，直到遇到break语句为止
4.如果没有匹配成功，则执行default后的语句体，直到遇到break语句为止
注意：default是可选的，可以根据需要选择性地使用
示例：
int day;
cin >> day;
switch( day )
{
case 1:
cout << "今天是星期一" << endl;
break;
case 2:
cout << "今天是星期二" << endl;
break;
case 3:
cout << "今天是星期三" << endl;
break;
case 4:
cout << "今天是星期四" << endl;
break;
case 5:
cout << "今天是星期五" << endl;
break;
case 6:
cout << "今天是星期六" << endl;
break;
case 7:
cout << "今天是星期日" << endl;
break;
default:
cout << "输入有误" << endl;
break;
}
当用户输入1时，会输出今天是星期一；当用户输入8时，会输出输入有误
注意：switch语句只能用于整型表达式，不能用于浮点型、字符型、字符串型等其他类型
switch语句中的case后的常量值必须是唯一的，不能重复
switch语句中的break语句是可选的，但建议每个case后都加上break语句，防止出现穿透现象
switch语句中的整型表达式可以是整型变量、整型常量、整型运算表达式等，但不能是浮点型、字符型、字符串型等其他类型
switch语句中的case后的常量值必须是整型常量，不能是变量、表达式等其他类型
switch语句中的default是可选的，可以根据需要选择性地使用
switch语句可以嵌套使用，但不建议过度嵌套，影响代码可读性
示例：
int a;
cin >> a;
switch( a )
{
case 1:
switch( a + 1 )
{
case 2:
cout << "a等于1，a+1等于2" << endl;
break;
default:
cout << "a等于1，a+1不等于2" << endl;
break;
}
break;
default:
cout << "a不等于1" << endl;
break;
}
当用户输入1时，会输出a等于1，a+1等于2；当用户输入2时，会输出a不等于1
注意：嵌套的switch语句的执行完全依赖于外层switch语句的条件表达式是否匹配成功
*/

//循环结构
/*
1.while循环语句
语法： 
while( 条件表达式 )
{
语句体；
}
执行流程：
当条件表达式为true时，执行语句体，然后再次判断条件表达式，直到条件表达式为false时，跳出循环
当条件表达式一开始就为false时，语句体一次都不会执行
示例：
int a 1;
while( a <= 5 )
{
cout << a << endl;
a++;
}
结果为
1
2
3
4
5

2. do...while循环语句
语法： 
do
{
语句体；
} 
while( 条件表达式 );
执行流程：
先执行一次语句体，然后判断条件表达式是否为true，如果为true，则继续执行语句体，然后再次判断条件表达式，直到条件表达式为false时，跳出循环
如果条件表达式一开始就为false时，语句体至少会执行一次
示例：
int a 1;
do
{
cout << a << endl;
a++;
} while( a <= 5 );
结果为
1
2
3
4
5

3. for循环语句
语法： for( 初始化表达式 ; 条件表达式 ; 更新表达式 )
{
语句体；
}
执行流程：
1.执行初始化表达式
2.判断条件表达式是否为true，如果为true，则执行语句体，然后执行更新表达式，然后再次判断条件表达式，直到条件表达式为false时，跳出循环
3.如果条件表达式一开始就为false时，语句体一次都不会执行
示例：
for( int a = 1; a <= 5; a++ )
{
cout << a << endl;
}
结果为
1
2
3
4
5
4. break语句
语法： break;
作用：用于跳出当前循环或switch语句
示例：
for( int a = 1; a <= 10; a++ )
{
if( a == 5 )
{
break;
}
cout << a << endl;
}
结果为
1
2
3
4
当a等于5时，跳出循环，不再执行后续的语句体
5. continue语句
语法： continue;
作用：用于跳过当前循环中的某次迭代，直接进入下一次迭代	
示例：
for( int a = 1; a <= 10; a++ )
{
if( a == 5 )
{
continue;
}
cout << a << endl;
}
结果为
1
2
3
4
6
7
8
9
10
当a等于5时，跳过此次迭代，不执行cout语句，直接进入下一次迭代

6. 无限循环
语法：
while( true )
{
语句体；
}
或
for( ; ; )
{
语句体；
}
执行流程：
循环条件永远为true，语句体会一直执行下去，直到程序被强制终止
示例：
while( true )
{
cout << "这是一个无限循环" << endl;
}
或
for( ; ; )
{
cout << "这是一个无限循环" << endl;
}
结果为
这是一个无限循环
这是一个无限循环
这是一个无限循环
...
注意：无限循环会导致程序无法正常结束，建议在语句体中加入break语句或其他跳出循环的条件，防止程序卡死

7. 嵌套循环
语法：
for( 初始化表达式1 ; 条件表达式1 ; 更新表达式1 )
{
for( 初始化表达式2 ; 条件表达式2 ; 更新表达式2 )
{
语句体；
}
}
执行流程：
外层循环控制内层循环的执行次数，内层循环每执行完一次，外层循环就会更新一次
示例：
for( int i = 1; i <= 3; i++ )
{
for( int j = 1; j <= 2; j++ )
{
cout << "i=" << i << ", j=" << j << endl;
}
}
结果为
i=1, j=1
i=1, j=2
i=2, j=1
i=2, j=2
i=3, j=1
i=3, j=2
注意：嵌套循环会增加程序的复杂度，建议在使用时注意代码的可读性和维护性

8.goto语句
语法： goto 标签名;
标签名:
标签名:
作用：用于无条件跳转到程序中的某个位置
示例：
int a = 1;
loop_start:
if( a <= 5 )
{
cout << a << endl;
a++;
goto loop_start;
}
结果为
1
2
3
4
5
注意：goto语句会破坏程序的结构化，建议尽量避免使用，除非在某些特殊情况下，如跳出多层嵌套循环等

*/

//数组
/*
一个数据的集合，放在一块连续的内存空间里，数组中的数据类型相同
1.一维数组
定义方法：数据类型 数组名[数组大小];
		  数据类型 数组名[] = {初始值1, 初始值2, ..., 初始值n}; 省略数组大小，由初始值个数推断
		  数据类型 数组名[数组大小] = {初始值1, 初始值2, ..., 初始值n};
		  注意：数组大小必须是一个常量表达式，不能是变量或浮点数
例如：int arr[5]; 表示定义一个名为arr的整型数组，数组大小为5，该数组中可以存放5个整型数据，索引范围为0~4，即arr[0]~arr[4]
		int arr[] = {1, 2, 3, 4, 5}; 表示定义一个名为arr的整型数组，数组大小为5，该数组中存放了5个整型数据，索引范围为0~4，即arr[0]~arr[4]
		int arr[5] = {1, 2}; 表示定义一个名为arr的整型数组，数组大小为5，该数组中存放了2个初始值，剩余的3个元素会被自动初始化为0，索引范围为0~4，即arr[0]~arr[4]，arr[0]=1, arr[1]=2, arr[2]=0, arr[3]=0, arr[4]=0
		访问数组元素：通过索引访问数组中的某个元素，索引从0开始
		例如：cout << arr[0] << endl; // 输出数组arr的第一个元素
		注意：访问数组元素时，索引不能越界，否则会导致程序异常
		[]中的值叫做下标，表示数组元素在数组中的位置，从0开始计数
		操作数组和操纵变量类似，可以进行赋值、运算等操作
应用示例：
int arr[5] = {1, 2, 3, 4, 5};
for( int i = 0; i < 5; i++ )
{
	cout << arr[i] << " ";
}
结果为 1 2 3 4 5

一维数组名：数组名表示数组的首地址，即数组第一个元素的地址
如：cout << arr << endl; // 输出数组arr的首地址
	cout << &arr[0] << endl; // 输出数组arr第一个元素的地址，结果与上面相同
sizeof(数组名)：表示数组所占的总内存大小
sizeof(数组名[0])：表示数组中每个元素所占的内存大小
sizeof(数组名) / sizeof(数组名[0])：表示数组的元素个数

冒泡排序法：
冒泡排序法是一种简单的排序算法，其基本思想是通过多次比较和交换相邻元素，将较大的元素逐渐“冒泡”到数组的末端，从而实现数组的排序。具体步骤如下：
1. 比较相邻的元素。如果第一个元素比第二个元素大，就交换它们的位置。
2. 对每一对相邻元素重复步骤1，直到数组的最后一个元素。此时，最后一个元素是最大的。
3. 忽略最后一个元素，对剩余的元素重复步骤1和步骤2，直到整个数组有序。
应用示例：
#include <iostream>
using namespace std;
int main()
{
	int arr[] = {5, 2, 9, 1, 5, 6};
	int n = sizeof(arr) / sizeof(arr[0]);
	for( int i = 0; i < n - 1; i++ )          //排序总轮数=数组元素个数-1
	{
		for( int j = 0; j < n - i - 1; j++ )  //每轮比较的次数=数组元素个数-1-排序轮数（第几轮）
		{
			if( arr[j] > arr[j + 1] )
			{
				// 交换 arr[j] 和 arr[j + 1]
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
	cout << "排序后的数组: ";
	for( int i = 0; i < n; i++ )
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	return 0;
}
*/
/*
2.二维数组
定义方法：数据类型 数组名[行数][列数];
		  数据类型 数组名[][列数] = { {初始值1, 初始值2, ..., 初始值n}, {初始值1, 初始值2, ..., 初始值n}, ... }; 省略行数，由初始值个数推断
		  数据类型 数组名[行数][] = { {初始值1, 初始值2, ..., 初始值n}, {初始值1, 初始值2, ..., 初始值n}, ... }; 省略列数，由每行初始值个数推断
		  数据类型 数组名[行数][列数] = { {初始值1, 初始值2, ..., 初始值n}, {初始值1, 初始值2, ..., 初始值n}, ... };
		  数据类型 数组名[行数][列数] = { 初始值1, 初始值2, ..., 初始值n }; 按行优先顺序依次赋值
		  例如：int arr[3][4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }; 表示该数组的12个位置从左到右从上到下依次被赋值为1~12
		  推荐写成：
		  int arr[3][4] = 
		  {
		  {1, 2, 3, 4},
		  {5, 6, 7, 8},
		  {9, 10, 11, 12}
		  };
		  比较直观
		  注意：行数和列数必须是常量表达式，不能是变量或浮点数

		  例如：int arr[3][4]; 表示定义一个名为arr的二维整型数组，数组有3行4列，该数组中可以存放12个整型数据，索引范围为arr[0][0]~arr[2][3]
		  int arr[][4] = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} }; 表示定义一个名为arr的二维整型数组，数组有3行4列，该数组中存放了12个整型数据，索引范围为arr[0][0]~arr[2][3]
		  int arr[3][4] = { {1, 2}, {5, 6, 7}, {9} }; 表示定义一个名为arr的二维整型数组，数组有3行4列，该数组中存放了5个初始值，剩余的元素会被自动初始化为0，
		  索引范围为arr[0][0]~arr[2][3]，arr[0][0]=1, arr[0][1]=2, arr[0][2]=0, arr[0][3]=0, arr[1][0]=5, arr[1][1]=6, arr[1][2]=7, arr[1][3]=0, arr[2][0]=9, arr[2][1]=0, arr[2][2]=0, arr[2][3]=0
		  第一行的四个值中的前两个值被初始化为1和2，后两个值没有被赋值，所以自动初始化为0
		  第二行的四个值中的前三个值被初始化为5、6和7，后一个值没有被赋值，所以自动初始化为0
		  第三行的四个值中的第一个值被初始化为9，后面三个值没有被赋值，所以自动初始化为0

		  访问数组元素：通过行索引和列索引访问数组中的某个元素，索引从0开始
		  例如：cout << arr[0][0] << endl; // 输出数组arr的第一个元素
		  应用示例：
		  int arr[3][4] = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} };
		  for( int i = 0; i < 3; i++ )
		  {
			  for( int j = 0; j < 4; j++ )
			  {
				  cout << arr[i][j] << " ";
			  }
			  cout << endl;
		  }
		  结果为
		  1 2 3 4
		  5 6 7 8
		  9 10 11 12
二维数组名：数组名表示数组的首地址，即数组第一个元素的地址
如：cout << arr << endl; // 输出数组arr的首地址
	cout << &arr[0][0] << endl; // 输出数组arr第一个元素的地址，结果与上面相同
	cout << arr[0] << endl; // 输出数组arr第一行的首地址
	cout << arr[1] << endl; // 输出数组arr第二行的首地址
	sizeof(数组名)：                             表示数组所占的总内存大小
	sizeof(数组名[0])：                          表示数组中每行所占的内存大小
	sizeof(数组名[0][0])：                       表示数组中每个元素所占的内存大小
	sizeof(数组名) / sizeof(数组名[0][0])：      表示数组的元素个数
	sizeof(数组名) / sizeof(数组名[0])：         表示数组的行数
	sizeof(数组名[0]) / sizeof(数组名[0][0])：   表示数组的列数


*/