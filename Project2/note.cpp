#include<iostream>
using namespace std;

/*main函数是程序的入口,每一个程序都必须有且仅有一个main函数*/

//单行注释
/*多行注释*/

//变量
/*变量的作用是给一段内存命名,方便操作这段内存
变量创建的语法:数据类型 变量名 = 变量初始值;
例如:int name = 5; 表示一个名叫name的整数变量的初始值值为5,int表示该变量的类型是整数
输出示例:cout <<"b="<< name << endl;
输出为b=5 */

//常量
/*常量定义的方式:宏常量,const修饰变量
1.宏常量:#define 名称 数值;如:
#define day 7
输出:cout << "一周有:" << day << "天" << endl;
2.修饰变量:const 变量类型 名称 = 值;如
const int month = 12;
输出: cout << "一年有:" << month << "月" << endl; */

//标识符
/*关键字(又称标识符,如int):
给标识符(如变量)起名的时候,只能使用字母,数字,下划线;
且不能用关键字;
且第一个字符必须为字母或者下划线;
且区分大小写*/

//数据类型
/*一个变量或常量必须有数据类型,用于给变量合理的内存空间

1.sizeof关键字:统计数据类型所占的内存大小
语法: sizeof( 数据类型 ) 或 sizeof( 变量 )
输出演示:cout << " a占用的空间内存为 " << sizeof( a ) << endl;

2.整型:用于表示整数
(1)整型:int
(2)短整型:short
(3)长整型:long
(4)长长整型:longlong
占用的内存空间不同,以至于取值范围不同
3.实型(浮点型):用于表示小数
(1)单精度:float (使用时常在变量初始值后方加上一个"f",否则编译器会将该数据默认为双精度,然后再将其转化为单精度,示例:float a = 3.14f)
(2)双精度:double
科学计数法:如3e2 表示3*100, 3e-2 表示0.03
表示的有效数字范围不同,占用的内存空间也不同
4.字符型:用于显示单个字符
语法:char ch = 'a';
注意:显示字符型变量时,用单引号括起来,而不是用双引号;单引号内只能有一个字符,不能是字符串
字符型变量并不是吧字符本身放在内存中储存,而是将对应的ASCII编码放入储存单元
将字符型强制转化为整型:cout << (int)ch << endl; a对应的编码为,所以输出97 b对应98 A对应65
5.转义字符:用于表示不能显示出来的ASCII字符
换行符:\n
反斜杠:\\
水平制表符:\t
6.字符串型:表示一串字符
(1)C风格字符串: char 变量名[] = "字符串值"
应用: char str[] = "hello world";
cout << str << endl;
(2)C++风格字符串: string 变量名 = "字符串值"
应用(需包含头文件:#include <string> )string str = "hello world";
cout << str << endl;
7.布尔类型:代表真或假的值
ture  表示真(1)
false 表示假(0)
语法:bool flag = true;
*/

//数据的输入
/*用于从键盘获取数据
语法:cin >> 变量名;
用法;当程序运行到这一行时,会等待用户为其赋值,赋值之后才会继续执行程序
*/

//算数运算符
/*
+ 正号
- 负号
+ 加
- 减
* 乘
/ 除

使用示例:
int a = 10;
int b = 2;
cout << a + b << endl;
cout << a / b << endl;
double d1 = 0.5;
double d2 = 0.22;
cout << d1 / d2 << endl;
则会输出
13
3
2.27273
(因为a,b两个变量都是整型,所以输出的结果会把小数部分全部舍去,不论小数多大,都直接切掉,如0.5会舍成0)
此外0不能作除数,否则会报错

% 取模(取余)

使用示例:
int a 10;
int b 3;
cout << a % b << endl;
int c 10;
int d 20;
cout << c % d << endl;
输出结果:
1
10
取模运算的时候0也不能做除数
两个小数之间不能做取模运算

++ 前置递增:先让变量加1,再进行表达式的运算
++ 后置递增
-- 前置递减
-- 后置递减:先进行表达式的运算,再让变量减1

使用示例:
int a 11;
++a;
cout << a << endl;
int b 11;
b--;
cout << b << endl;
int c 10;
int d ++c * 10;
cout << c << endl;
cout << d << endl;
int e 10;
int f e++ * 10;
cout << e << endl;
cout << f << endl;
输出:
12
10
11
110
11
100
*/

//赋值运算符
/*
=  赋值      不论左边变量的类型是什么,右边的值都会被强制转化为左边变量的类型
+= 加后赋值  a += b 等价于 a = a + b
-= 减后赋值  a -= b 等价于 a = a - b
*= 乘后赋值  a *= b 等价于 a = a * b
/= 除后赋值  a /= b 等价于 a = a / b
%= 取模后赋值a %= b 等价于 a = a % b
*/

//关系运算符(比较运算符)
/*
== 等于       4==4 结果为true  4==5 结果为false
!= 不等于     4!=5 结果为true  4!=4 结果为false
> 大于        4>5 结果为false  5>4 结果为true
< 小于        4<5 结果为true   5<4 结果为false
>= 大于等于   4>=4 结果为true  4>=5 结果为false
<= 小于等于   4<=5 结果为true  5<=4 结果为false
关系运算符的结果是布尔类型,true或false (1或0)
关系运算符可以进行链式操作,如 3 < a < 10
注意:= 是赋值运算符,== 是关系运算符
示例:
int a 5;
cout << (a == 5) << endl;
cout << (a != 5) << endl;
结果为
1
0
*/

//逻辑运算符
/*
! 逻辑非(取反)  !true 结果为false  !false 结果为true
示例:
bool flag = true;
cout << !flag << endl;
结果为0
int a = 5;
cout << !(a > 1) << endl;
结果为0
int a = 5;
cout << !a << endl;
结果为0  因为a不等于0,所以a为true,!a为false
(C++中0表示false,非0的任何数都表示true)

&& 逻辑与(短路与)  只有两个操作数都为true,结果才为true,否则为false
示例:
bool flag1 = true;
bool flag2 = false;
cout << (flag1 && flag2) << endl;
结果为0

|| 逻辑或(短路或)  只要两个操作数有一个为true,结果就为true,否则为false
示例:
bool flag1 = true;
bool flag2 = false;
cout << (flag1 || flag2) << endl;
结果为1

逻辑运算符的结果是布尔类型,true或false (1或0)
逻辑运算符可以进行链式操作,如 a > 1 && a < 10
注意:逻辑运算符的优先级低于关系运算符
*/

//程序流程结构
/*
顺序结构:按代码的先后顺序依次执行,没有任何跳转
选择结构:根据条件的真假,选择性地执行某些代码
(1)单分支结构:if语句
语法: if( 条件表达式 )
{
语句体;
}
执行流程:当条件表达式为true时,执行语句体;当条件表达式为false时,不执行语句体,直接跳过
示例:
int a;
cin >> a;
if( a > 5 )
{
cout << "a大于5" << endl;
}
cout << "程序结束" << endl;
当用户输入的a大于5时,会输出a大于5和程序结束;当用户输入的a小于等于5时,只会输出程序结束
如果不加大括号,只能执行一条语句
int a=5;
if(a>10)
cout <<a;  //此语句受if限制
cout <<a;  //此语句不受if限制
则输出 5

(2)双分支结构:if...else语句
语法: if( 条件表达式 )
{
语句体1;
}
else
{
语句体2;
}
执行流程:当条件表达式为true时,执行语句体1;当条件表达式为false时,执行语句体2
示例:
int a;
cin >> a;
if( a > 5 )
{
cout << "a大于5" << endl;
}
else
{
cout << "a小于等于5" << endl;
}
cout << "程序结束" << endl;
当用户输入的a大于5时,会输出a大于5和程序结束;当用户输入的a小于等于5时,会输出a小于等于5和程序结束

(3)多分支结构:if...else if...else语句
语法: if( 条件表达式1 )
{
语句体1;
}
else if( 条件表达式2 )
{
语句体2;
}
else if( 条件表达式3 )
{
语句体3;
}
...
else
{
语句体n;
}
执行流程:从上到下依次判断条件表达式,直到有一个条件表达式为true时,执行对应的语句体,后续的条件表达式不再判断;如果所有条件表达式都为false时,执行else后的语句体
示例:
int a;
cin >> a;
if( a > 5 )
{
cout << "a大于5" << endl;
}
else if( a == 5 )
{
cout << "a等于5" << endl;
}
else
{
cout << "a小于5" << endl;
}
cout << "程序结束" << endl;
当用户输入的a大于5时,会输出a大于5和程序结束;当用户输入的a等于5时,会输出a等于5和程序结束;当用户输入的a小于5时,会输出a小于5和程序结束
注意:多分支结构中,else if和else都是可选的,可以根据需要选择性地使用

(4)嵌套结构:在if语句的语句体中再使用if语句
示例:
int a;
cin >> a;
if( a > 5 )
{
if( a < 10 )
{
cout << "a大于5且小于10" << endl;
}
else
{
cout << "a大于等于10" << endl;
}
}
else
{
cout << "a小于等于5" << endl;
}
cout << "程序结束" << endl;
当用户输入的a大于5且小于10时,会输出a大于5且小于10和程序结束;当用户输入的a大于等于10时,会输出a大于等于10和程序结束;当用户输入的a小于等于5时,会输出a小于等于5和程序结束
注意:嵌套结构中,内层if语句的执行完全依赖于外层if语句的条件表达式是否为true

三目运算符:条件表达式 ? 表达式1 : 表达式2
执行流程:
当条件表达式为true时,执行表达式1,并将表达式1的结果作为整个三目运算符的结果
当条件表达式为false时,执行表达式2,并将表达式2的结果作为整个三目运算符的结果
示例:
int a;
cin >> a;
int b = ( a > 5 ) ? 100 : 200;
cout << b << endl;
当用户输入的a大于5时,b的值为100;当用户输入的a小于等于5时,b的值为200
注意:三目运算符可以嵌套使用,但不建议过度嵌套,影响代码可读性
示例:
int a;
cin >> a;
int b = ( a > 5 ) ? ( ( a < 10 ) ? 100 : 200 ) : 300;
cout << b << endl;
当用户输入的a大于5且小于10时,b的值为100;当用户输入的a大于等于10时,b的值为200;当用户输入的a小于等于5时,b的值为300
注意:三目运算符的优先级低于关系运算符,高于赋值运算符

switch语句:多分支选择结构的另一种实现方式
语法: switch( 非浮点型表达式 )
{
case 常量值1:
语句体1;
break;
case 常量值2:
语句体2;
break;
...
default:
语句体n;
break;
}
执行流程:
1.计算整型表达式的值
2.将计算结果与各case后的常量值进行比较
3.如果匹配成功,则执行对应的语句体,直到遇到break语句为止
4.如果没有匹配成功,则执行default后的语句体,直到遇到break语句为止
注意:default是可选的,可以根据需要选择性地使用
示例:
int day;
cin >> day;
switch( day )
{
case 1:
cout << "今天是星期一" << endl;
break;
case 2:
cout << "今天是星期二" << endl;
break;
case 3:
cout << "今天是星期三" << endl;
break;
case 4:
cout << "今天是星期四" << endl;
break;
case 5:
cout << "今天是星期五" << endl;
break;
case 6:
cout << "今天是星期六" << endl;
break;
case 7:
cout << "今天是星期日" << endl;
break;
default:
cout << "输入有误" << endl;
break;
}
当用户输入1时,会输出今天是星期一;当用户输入8时,会输出输入有误
注意:switch语句只能用于整型表达式,不能用于浮点型、字符型、字符串型等其他类型
switch语句中的case后的常量值必须是唯一的,不能重复
switch语句中的break语句是可选的,但建议每个case后都加上break语句,防止出现穿透现象
(遇到break会立马跳出大括号,没遇到break则会按序往下进行)
switch语句中的整型表达式可以是整型变量、整型常量、整型运算表达式等,但不能是浮点型、字符型、字符串型等其他类型
switch语句中的case后的常量值必须是整型常量,不能是变量、表达式等其他类型
switch语句中的default是可选的,可以根据需要选择性地使用
switch语句可以嵌套使用,但不建议过度嵌套,影响代码可读性
示例:
int a;
cin >> a;
switch( a )
{
case 1:
switch( a + 1 )
{
case 2:
cout << "a等于1,a+1等于2" << endl;
break;
default:
cout << "a等于1,a+1不等于2" << endl;
break;
}
break;
default:
cout << "a不等于1" << endl;
break;
}
当用户输入1时,会输出a等于1,a+1等于2;当用户输入2时,会输出a不等于1
注意:嵌套的switch语句的执行完全依赖于外层switch语句的条件表达式是否匹配成功
*/

//循环结构
/*
1.while循环语句
语法:
while( 条件表达式 )
{
语句体;
}
执行流程:
当条件表达式为true时,执行语句体,然后再次判断条件表达式,直到条件表达式为false时,跳出循环
当条件表达式一开始就为false时,语句体一次都不会执行
示例:
int a 1;
while( a <= 5 )
{
cout << a << endl;
a++;
}
结果为
1
2
3
4
5

2. do...while循环语句
语法:
do
{
语句体;
}
while( 条件表达式 );
执行流程:
先执行一次语句体,然后判断条件表达式是否为true,如果为true,则继续执行语句体,然后再次判断条件表达式,直到条件表达式为false时,跳出循环
如果条件表达式一开始就为false时,语句体至少会执行一次
示例:
int a 1;
do
{
cout << a << endl;
a++;
} while( a <= 5 );
结果为
1
2
3
4
5

3. for循环语句
语法: for( 初始化表达式 ; 条件表达式 ; 更新表达式 )
{
语句体;
}
执行流程:
1.执行初始化表达式
2.判断条件表达式是否为true,如果为true,则执行语句体,然后执行更新表达式,然后再次判断条件表达式,直到条件表达式为false时,跳出循环
3.如果条件表达式一开始就为false时,语句体一次都不会执行
示例:
for( int a = 1; a <= 5; a++ )
{
cout << a << endl;
}
结果为
1
2
3
4
5
4. break语句
语法: break;
作用:用于跳出当前循环或switch语句
示例:
for( int a = 1; a <= 10; a++ )
{
if( a == 5 )
{
break;
}
cout << a << endl;
}
结果为
1
2
3
4
当a等于5时,跳出循环,不再执行后续的语句体

5. continue语句
语法: continue;
作用:用于中止当前循环,直接进入下一次循环
示例:
for( int a = 1; a <= 10; a++ )
{
if( a == 5 )
{
continue;
}
cout << a << endl;
}
结果为
1
2
3
4
6
7
8
9
10
当a等于5时,跳过此次迭代,不执行cout语句,直接进入下一次迭代

6. 无限循环
语法:
while( true )
{
语句体;
}
或
for( ; ; )
{
语句体;
}
执行流程:
循环条件永远为true,语句体会一直执行下去,直到程序被强制终止
示例:
while( true )
{
cout << "这是一个无限循环" << endl;
}
或
for( ; ; )
{
cout << "这是一个无限循环" << endl;
}
结果为
这是一个无限循环
这是一个无限循环
这是一个无限循环
...
注意:无限循环会导致程序无法正常结束,建议在语句体中加入break语句或其他跳出循环的条件,防止程序卡死

7. 嵌套循环
语法:
for( 初始化表达式1 ; 条件表达式1 ; 更新表达式1 )
{
for( 初始化表达式2 ; 条件表达式2 ; 更新表达式2 )
{
语句体;
}
}
执行流程:
外层循环控制内层循环的执行次数,内层循环每执行完一次,外层循环就会更新一次
示例:
for( int i = 1; i <= 3; i++ )
{
for( int j = 1; j <= 2; j++ )
{
cout << "i=" << i << ", j=" << j << endl;
}
}
结果为
i=1, j=1
i=1, j=2
i=2, j=1
i=2, j=2
i=3, j=1
i=3, j=2
注意:嵌套循环会增加程序的复杂度,建议在使用时注意代码的可读性和维护性

8.goto语句
语法: goto 标签名;
标签名:
标签名:
作用:用于无条件跳转到程序中的某个位置
示例:
int a = 1;
loop_start:
if( a <= 5 )
{
cout << a << endl;
a++;
goto loop_start;
}
结果为
1
2
3
4
5
注意:goto语句会破坏程序的结构化,建议尽量避免使用,除非在某些特殊情况下,如跳出多层嵌套循环等

*/

//数组
/*
一个数据的集合,放在一块连续的内存空间里,数组中的数据类型相同
1.一维数组
定义方法:数据类型 数组名[数组大小];
		  数据类型 数组名[] = {初始值1, 初始值2, ..., 初始值n}; 省略数组大小,由初始值个数推断
		  数据类型 数组名[数组大小] = {初始值1, 初始值2, ..., 初始值n};
		  注意:数组大小必须是一个常量表达式,不能是变量或浮点数
例如:int arr[5]; 表示定义一个名为arr的整型数组,数组大小为5,该数组中可以存放5个整型数据,索引范围为0~4,即arr[0]~arr[4]
		int arr[] = {1, 2, 3, 4, 5}; 表示定义一个名叫arr的整型数组,数组大小为5,该数组中存放了5个整型数据,索引范围为0~4,即arr[0]~arr[4]
		int arr[5] = {1, 2}; 表示定义一个名为arr的整型数组,数组大小为5,该数组中存放了2个初始值,剩余的3个元素会被自动初始化为0,索引范围为0~4,即arr[0]~arr[4],arr[0]=1,arr[1]=2,arr[2]=0,arr[3]=0,arr[4]=0
		访问数组元素:通过索引访问数组中的某个元素,索引从0开始
		例如:cout << arr[0] << endl; // 输出数组arr的第一个元素
		注意:访问数组元素时,索引不能越界,否则会导致程序异常
		[]中的值叫做下标,表示数组元素在数组中的位置,从0开始计数
		操作数组和操纵变量类似,可以进行赋值、运算等操作
应用示例:
int arr[5] = {1, 2, 3, 4, 5};
for( int i = 0; i < 5; i++ )
{
	cout << arr[i] << " ";
}
结果为 1 2 3 4 5

一维数组名:数组名表示数组的首地址,即数组第一个元素的地址
如:cout << arr << endl; // 输出数组arr的首地址
	cout << &arr[0] << endl; // 输出数组arr第一个元素的地址,结果与上面相同
sizeof(数组名):表示数组所占的总内存大小
sizeof(数组名[0]):表示数组中每个元素所占的内存大小
sizeof(数组名) / sizeof(数组名[0]):表示数组的元素个数

冒泡排序法:
冒泡排序法是一种简单的排序算法,其基本思想是通过多次比较和交换相邻元素,将较大的元素逐渐"冒泡"到数组的末端,从而实现数组的排序。具体步骤如下:
1. 比较相邻的元素。如果第一个元素比第二个元素大,就交换它们的位置。
2. 对每一对相邻元素重复步骤1,直到数组的最后一个元素。此时,最后一个元素是最大的。
3. 忽略最后一个元素,对剩余的元素重复步骤1和步骤2,直到整个数组有序。
应用示例:
#include <iostream>
using namespace std;
int main()
{
	int arr[] = {5, 2, 9, 1, 5, 6};
	int n = sizeof(arr) / sizeof(arr[0]);
	for( int i = 0; i < n - 1; i++ )          //排序总轮数=数组元素个数-1
	{
		for( int j = 0; j < n - i - 1; j++ )  //每轮比较的次数=数组元素个数-1-排序轮数(第几轮)
		{
			if( arr[j] > arr[j + 1] )
			{
				// 交换 arr[j] 和 arr[j + 1]
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
	cout << "排序后的数组: ";
	for( int i = 0; i < n; i++ )
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	return 0;
}
*/
/*
2.二维数组
定义方法:数据类型 数组名[行数][列数];
		  数据类型 数组名[][列数] = { {初始值1, 初始值2, ..., 初始值n}, {初始值1, 初始值2, ..., 初始值n}, ... }; 省略行数,由初始值个数推断
		  数据类型 数组名[行数][] = { {初始值1, 初始值2, ..., 初始值n}, {初始值1, 初始值2, ..., 初始值n}, ... }; 省略列数,由每行初始值个数推断
		  数据类型 数组名[行数][列数] = { {初始值1, 初始值2, ..., 初始值n}, {初始值1, 初始值2, ..., 初始值n}, ... };
		  数据类型 数组名[行数][列数] = { 初始值1, 初始值2, ..., 初始值n }; 按行优先顺序依次赋值
		  例如:int arr[3][4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }; 表示该数组的12个位置从左到右从上到下依次被赋值为1~12
		  推荐写成:
		  int arr[3][4] =
		  {
		  {1, 2, 3, 4},
		  {5, 6, 7, 8},
		  {9, 10, 11, 12}
		  };
		  比较直观
		  注意:行数和列数必须是常量表达式,不能是变量或浮点数

		  例如:int arr[3][4]; 表示定义一个名为arr的二维整型数组,数组有3行4列,该数组中可以存放12个整型数据,索引范围为arr[0][0]~arr[2][3]
		  int arr[][4] = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} }; 表示定义一个名为arr的二维整型数组,数组有3行4列,该数组中存放了12个整型数据,索引范围为arr[0][0]~arr[2][3]
		  int arr[3][4] = { {1, 2}, {5, 6, 7}, {9} }; 表示定义一个名为arr的二维整型数组,数组有3行4列,该数组中存放了5个初始值,剩余的元素会被自动初始化为0,
		  索引范围为arr[0][0]~arr[2][3],arr[0][0]=1,arr[0][1]=2,arr[0][2]=0,arr[0][3]=0,arr[1][0]=5,arr[1][1]=6,arr[1][2]=7,arr[1][3]=0,arr[2][0]=9,arr[2][1]=0,arr[2][2]=0,arr[2][3]=0
		  第一行的四个值中的前两个值被初始化为1和2,后两个值没有被赋值,所以自动初始化为0
		  第二行的四个值中的前三个值被初始化为5、6和7,后一个值没有被赋值,所以自动初始化为0
		  第三行的四个值中的第一个值被初始化为9,后面三个值没有被赋值,所以自动初始化为0

		  访问数组元素:通过行索引和列索引访问数组中的某个元素,索引从0开始
		  例如:cout << arr[0][0] << endl; // 输出数组arr的第一个元素
		  应用示例:
		  int arr[3][4] = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} };
		  for( int i = 0; i < 3; i++ )
		  {
			  for( int j = 0; j < 4; j++ )
			  {
				  cout << arr[i][j] << " ";
			  }
			  cout << endl;
		  }
		  结果为
		  1 2 3 4
		  5 6 7 8
		  9 10 11 12
二维数组名:数组名表示数组的首地址,即数组第一个元素的地址
如:cout << arr << endl; // 输出数组arr的首地址
	cout << &arr[0][0] << endl; // 输出数组arr第一个元素的地址,结果与上面相同
	cout << arr[0] << endl; // 输出数组arr第一行的首地址
	cout << arr[1] << endl; // 输出数组arr第二行的首地址
	sizeof(数组名):                             表示数组所占的总内存大小
	sizeof(数组名[0]):                          表示数组中每行所占的内存大小
	sizeof(数组名[0][0]):                       表示数组中每个元素所占的内存大小
	sizeof(数组名) / sizeof(数组名[0][0]):      表示数组的元素个数
	sizeof(数组名) / sizeof(数组名[0]):         表示数组的行数
	sizeof(数组名[0]) / sizeof(数组名[0][0]):   表示数组的列数
*/
