#include<iostream>
using namespace std;

/*main芥版绋搴ュｏ姣涓涓绋搴藉椤绘涓浠涓涓main芥*/

//琛娉ㄩ
/*澶琛娉ㄩ*/

//
/*浣ㄦ缁涓娈靛瀛藉锛逛究浣杩娈靛瀛
寤虹璇娉锛版绫诲 ?= 濮硷
渚濡锛int name = 5; 琛ㄧず涓涓name存板濮煎间负5锛int琛ㄧず璇ュ绫诲存?
杈虹ず渚锛cout <<"b="<< name << endl;
杈轰负b=5 */

//甯搁
/*甯搁瀹涔瑰锛瀹甯搁锛const淇楗板
1.瀹甯搁锛#define 绉 板?濡锛
#define day 7
杈猴cout << "涓ㄦ锛? << day << "澶? << endl;
2.淇楗板锛const 绫诲 绉 = 硷濡?
const int month = 12;
杈: cout << "涓骞存锛? << month << "? << endl; */

//璇绗?
/*抽瀛锛绉版璇绗锛濡int锛锛
缁璇绗锛濡锛璧峰跺锛戒娇ㄥ姣锛板锛涓绾匡
涓涓界ㄥ抽瀛锛
涓绗涓涓瀛绗蹇椤讳负瀛姣涓绾匡?
涓哄澶у*/

//版绫诲
/*涓涓甯搁蹇椤绘版绫诲锛ㄤ缁瀛绌洪

1.sizeof抽瀛锛缁璁℃版绫诲瀛澶у
璇娉锛?sizeof( 版绫诲 ) ?sizeof锛? 锛?
杈烘绀猴cout << " aㄧ绌洪村瀛涓 " << sizeof( a ) << endl;

2.村锛ㄤ琛ㄧず存?
锛?锛村锛int
锛?锛村锛short
锛?锛挎村锛long
锛?锛块挎村锛longlong
ㄧ瀛绌洪翠锛浠ヨ充艰翠?
3.瀹锛娴瑰锛锛ㄤ琛ㄧず灏
锛?锛绮惧害锛float 锛浣跨ㄦ跺父ㄥ濮煎瑰涓涓涓f锛缂璇ㄤ灏璇ユ版榛璁や负绮惧害锛跺灏惰浆涓哄绮惧害锛绀轰锛float a = 3.14f)
锛?锛绮惧害锛double
绉瀛璁℃版锛濡?e2 琛ㄧず3*100, 3e-2 琛ㄧず0.03
琛ㄧず板翠锛ㄧ瀛绌洪翠涓
4.瀛绗锛ㄤ剧ず涓瀛绗
璇娉锛char ch = 'a';
娉ㄦ锛剧ず瀛绗讹ㄥ寮锋璧锋ワ涓ㄥ寮凤寮峰芥涓涓瀛绗锛涓芥瀛绗涓
瀛绗骞朵у绗韬惧ㄥ瀛涓ㄥ锛灏瀵瑰ASCII缂惧ュㄥ
灏瀛绗寮哄惰浆涓烘村锛cout << (int)ch << endl; a瀵瑰缂涓猴浠ヨ?7 b瀵瑰98 A瀵瑰65
5.杞涔瀛绗锛ㄤ琛ㄧず涓芥剧ず烘ョASCII瀛绗
㈣绗锛\n
锛\\
姘村钩惰〃绗锛\t
6.瀛绗涓插锛琛ㄧず涓涓插绗?
锛?锛C椋煎绗涓诧 char [] = "瀛绗涓插?
搴锛?char str[] = "hello world";
cout << str << endl;
锛?锛C++椋煎绗涓诧 string ?= "瀛绗涓插?
搴锛澶存浠讹#include <string> 锛string str = "hello world";
cout << str << endl;
7.甯灏绫诲锛浠ｈ〃?
ture  琛ㄧず锛1锛?
false 琛ㄧず锛0锛?
璇娉锛bool flag = true;
*/

//版杈?
/*ㄤ浠峰版?
璇娉锛cin >> ?
ㄦ;褰绋搴杩琛拌涓琛讹浼绛寰ㄦ蜂负惰硷璧间浼缁х画ц绋搴?
*/

//绠拌绠绗?
/*
+ 姝ｅ
- 璐
+ ?
- ?
* 涔?
/ ?

浣跨ㄧず渚锛?
int a = 10;
int b = 2;
cout << a + b << endl;
cout << a / b << endl;
double d1 = 0.5;
double d2 = 0.22;
cout << d1 / d2 << endl;
浼杈
13
3
2.27273
(涓a锛b涓や釜芥村锛浠ヨ虹缁浼灏伴ㄥㄩㄨ伙涓璁哄板澶э界存ュ锛濡?.5浼?)
姝ゅ0涓戒ゆ帮浼ラ?

% 妯★浣锛

浣跨ㄧず渚锛?
int a 10;
int b 3;
cout << a % b << endl;
int c 10;
int d 20;
cout << c % d << endl;
杈虹锛?
1
10
妯¤绠跺?涔涓藉ゆ
涓や釜灏颁翠藉妯¤绠?

++ 缃澧:璁╁?锛杩琛琛ㄨ揪寮杩绠
++ 缃澧
-- 缃
-- 缃锛杩琛琛ㄨ揪寮杩绠锛璁╁1

浣跨ㄧず渚锛?
int a 11;
++a;
cout << a << endl;
int b 11;
b--;
cout << b << endl;
int c 10;
int d ++c * 10;
cout << c << endl;
cout << d << endl;
int e 10;
int f e++ * 10;
cout << e << endl;
cout << f << endl;
杈猴?
12
10
11
110
11
100
*/

//璧艰绠绗
/*
=  璧?     涓璁哄乏杈瑰绫诲浠涔锛宠竟奸戒琚寮哄惰浆涓哄乏杈瑰绫诲
+= 璧? a += b 绛浠蜂?a = a + b
-= 璧? a -= b 绛浠蜂?a = a - b
*= 涔璧? a *= b 绛浠蜂?a = a * b
/= ゅ璧? a /= b 绛浠蜂?a = a / b
%= 妯″璧a %= b 绛浠蜂?a = a % b
*/

//崇郴杩绠绗锛姣杈杩绠绗锛
/*
== 绛浜       4==4 缁涓true  4==5 缁涓false
!= 涓绛浜?    4!=5 缁涓true  4!=4 缁涓false
> 澶т        4>5 缁涓false  5>4 缁涓true
< 灏浜        4<5 缁涓true   5<4 缁涓false
>= 澶т绛浜   4>=4 缁涓true  4>=5 缁涓false
<= 灏浜绛浜   4<=5 缁涓true  5<=4 缁涓false
崇郴杩绠绗缁甯灏绫诲锛truefalse (1?)
崇郴杩绠绗浠ヨ琛惧浣锛濡?3 < a < 10
娉ㄦ锛? 璧艰绠绗锛?= 崇郴杩绠绗
绀轰锛?
int a 5;
cout << (a == 5) << endl;
cout << (a != 5) << endl;
缁涓?
1
0
*/

//昏杩绠绗?
/*
锛?昏锛锛? !true 缁涓false  !false 缁涓true
绀轰锛?
bool flag = true;
cout << !flag << endl;
缁涓?
int a = 5;
cout << !(a > 1) << endl;
缁涓?
int a = 5;
cout << !a << endl;
缁涓?  涓a涓绛浜?锛浠a涓true锛?a涓false
锛C++涓?琛ㄧずfalse锛0浠讳伴借〃绀true锛?

&& 昏涓锛璺涓锛  涓や釜浣伴戒负true锛缁涓true锛涓false
绀轰锛?
bool flag1 = true;
bool flag2 = false;
cout << (flag1 && flag2) << endl;
缁涓?

|| 昏锛璺锛  瑕涓や釜浣版涓涓涓true锛缁灏变负true锛涓false
绀轰锛?
bool flag1 = true;
bool flag2 = false;
cout << (flag1 || flag2) << endl;
缁涓?

昏杩绠绗缁甯灏绫诲锛truefalse (1?)
昏杩绠绗浠ヨ琛惧浣锛濡?a > 1 && a < 10
娉ㄦ锛昏杩绠绗浼绾т浜崇郴杩绠绗
*/

//程序流程结构
/*
顺序结构：按代码的先后顺序依次执行，没有任何跳转
选择结构：根据条件的真假，选择性地执行某些代码
（1）单分支结构：if语句
语法： if( 条件表达式 )
{
语句体；
}
执行流程：当条件表达式为true时，执行语句体；当条件表达式为false时，不执行语句体，直接跳过
示例：
int a;
cin >> a;
if( a > 5 )
{
cout << "a大于5" << endl;
}
cout << "程序结束" << endl;
当用户输入的a大于5时，会输出a大于5和程序结束；当用户输入的a小于等于5时，只会输出程序结束
如果不加大括号，只能执行一条语句
int a=5; 
if(a>10)
cout <<a;  //此语句受if限制
cout <<a;  //此语句不受if限制
则输出 5

（2）双分支结构：if...else语句
语法： if( 条件表达式 )
{
语句体1；
}
else
{
语句体2；
}
执行流程：当条件表达式为true时，执行语句体1；当条件表达式为false时，执行语句体2
示例：
int a;
cin >> a;
if( a > 5 )
{
cout << "a大于5" << endl;
}
else
{
cout << "a小于等于5" << endl;
}
cout << "程序结束" << endl;
当用户输入的a大于5时，会输出a大于5和程序结束；当用户输入的a小于等于5时，会输出a小于等于5和程序结束

（3）多分支结构：if...else if...else语句
语法： if( 条件表达式1 )
{
语句体1；
}
else if( 条件表达式2 )
{
语句体2；
}
else if( 条件表达式3 )
{
语句体3；
}
...
else
{
语句体n；
}
执行流程：从上到下依次判断条件表达式，直到有一个条件表达式为true时，执行对应的语句体，后续的条件表达式不再判断；如果所有条件表达式都为false时，执行else后的语句体
示例：
int a;
cin >> a;
if( a > 5 )
{
cout << "a大于5" << endl;
}
else if( a == 5 )
{
cout << "a等于5" << endl;
}
else
{
cout << "a小于5" << endl;
}
cout << "程序结束" << endl;
当用户输入的a大于5时，会输出a大于5和程序结束；当用户输入的a等于5时，会输出a等于5和程序结束；当用户输入的a小于5时，会输出a小于5和程序结束
注意：多分支结构中，else if和else都是可选的，可以根据需要选择性地使用

（4）嵌套结构：在if语句的语句体中再使用if语句
示例：
int a;
cin >> a;
if( a > 5 )
{
if( a < 10 )
{
cout << "a大于5且小于10" << endl;
}
else
{
cout << "a大于等于10" << endl;
}
}
else
{
cout << "a小于等于5" << endl;
}
cout << "程序结束" << endl;
当用户输入的a大于5且小于10时，会输出a大于5且小于10和程序结束；当用户输入的a大于等于10时，会输出a大于等于10和程序结束；当用户输入的a小于等于5时，会输出a小于等于5和程序结束
注意：嵌套结构中，内层if语句的执行完全依赖于外层if语句的条件表达式是否为true

涓杩绠绗锛′欢琛ㄨ揪寮?? 琛ㄨ揪寮? : 琛ㄨ揪寮?
ц娴绋锛?
褰′欢琛ㄨ揪寮涓true讹ц琛ㄨ揪寮?锛骞跺琛ㄨ揪寮1缁浣涓烘翠釜涓杩绠绗缁?
褰′欢琛ㄨ揪寮涓false讹ц琛ㄨ揪寮?锛骞跺琛ㄨ揪寮2缁浣涓烘翠釜涓杩绠绗缁?
绀轰锛?
int a;
cin >> a;
int b = ( a > 5 ) ? 100 : 200;
cout << b << endl;
褰ㄦ疯ョa澶т5讹b间负100锛褰ㄦ疯ョa灏浜绛浜5讹b间负200
娉ㄦ锛涓杩绠绗浠ュ濂浣跨锛浣涓寤鸿杩搴宓濂锛褰卞浠ｇ璇绘?
绀轰锛?
int a;
cin >> a;
int b = ( a > 5 ) ? ( ( a < 10 ) ? 100 : 200 ) : 300;
cout << b << endl;
褰ㄦ疯ョa澶т5涓灏浜?0讹b间负100锛褰ㄦ疯ョa澶т绛浜10讹b间负200锛褰ㄦ疯ョa灏浜绛浜5讹b间负300
娉ㄦ锛涓杩绠绗浼绾т浜崇郴杩绠绗锛楂浜璧艰绠绗

switch语句：多分支选择结构的另一种实现方式
语法： switch( 非浮点型表达式 )
{
case 常量值1:
语句体1;
break;
case 常量值2:
语句体2;
break;
...
default:
语句体n;
break;
}
执行流程：
1.计算整型表达式的值
2.将计算结果与各case后的常量值进行比较
3.如果匹配成功，则执行对应的语句体，直到遇到break语句为止
4.如果没有匹配成功，则执行default后的语句体，直到遇到break语句为止
注意：default是可选的，可以根据需要选择性地使用
绀轰锛?
int day;
cin >> day;
switch( day )
{
case 1:
cout << "今天是星期一" << endl;
break;
case 2:
cout << "今天是星期二" << endl;
break;
case 3:
cout << "今天是星期三" << endl;
break;
case 4:
cout << "今天是星期四" << endl;
break;
case 5:
cout << "今天是星期五" << endl;
break;
case 6:
cout << "今天是星期六" << endl;
break;
case 7:
cout << "今天是星期日" << endl;
break;
default:
cout << "输入有误" << endl;
break;
}
当用户输入1时，会输出今天是星期一；当用户输入8时，会输出输入有误
注意：switch语句只能用于整型表达式，不能用于浮点型、字符型、字符串型等其他类型
switch语句中的case后的常量值必须是唯一的，不能重复
switch语句中的break语句是可选的，但建议每个case后都加上break语句，防止出现穿透现象
(遇到break会立马跳出大括号，没遇到break则会按序往下进行)
switch语句中的整型表达式可以是整型变量、整型常量、整型运算表达式等，但不能是浮点型、字符型、字符串型等其他类型
switch语句中的case后的常量值必须是整型常量，不能是变量、表达式等其他类型
switch语句中的default是可选的，可以根据需要选择性地使用
switch语句可以嵌套使用，但不建议过度嵌套，影响代码可读性
示例：
int a;
cin >> a;
switch( a )
{
case 1:
switch( a + 1 )
{
case 2:
cout << "a等于1，a+1等于2" << endl;
break;
default:
cout << "a等于1，a+1不等于2" << endl;
break;
}
break;
default:
cout << "a不等于1" << endl;
break;
}
当用户输入1时，会输出a等于1，a+1等于2；当用户输入2时，会输出a不等于1
注意：嵌套的switch语句的执行完全依赖于外层switch语句的条件表达式是否匹配成功
*/

//循环结构
/*
1.while循环语句
语法： 
while( 条件表达式 )
{
语句体；
}
执行流程：
当条件表达式为true时，执行语句体，然后再次判断条件表达式，直到条件表达式为false时，跳出循环
当条件表达式一开始就为false时，语句体一次都不会执行
示例：
int a 1;
while( a <= 5 )
{
cout << a << endl;
a++;
}
结果为
1
2
3
4
5

2. do...while循环语句
语法： 
do
{
语句体；
} 
while( 条件表达式 );
执行流程：
先执行一次语句体，然后判断条件表达式是否为true，如果为true，则继续执行语句体，然后再次判断条件表达式，直到条件表达式为false时，跳出循环
如果条件表达式一开始就为false时，语句体至少会执行一次
示例：
int a 1;
do
{
cout << a << endl;
a++;
} while( a <= 5 );
结果为
1
2
3
4
5

3. for循环语句
语法： for( 初始化表达式 ; 条件表达式 ; 更新表达式 )
{
语句体；
}
执行流程：
1.执行初始化表达式
2.判断条件表达式是否为true，如果为true，则执行语句体，然后执行更新表达式，然后再次判断条件表达式，直到条件表达式为false时，跳出循环
3.如果条件表达式一开始就为false时，语句体一次都不会执行
示例：
for( int a = 1; a <= 5; a++ )
{
cout << a << endl;
}
结果为
1
2
3
4
5
4. break语句
语法： break;
作用：用于跳出当前循环或switch语句
示例：
for( int a = 1; a <= 10; a++ )
{
if( a == 5 )
{
break;
}
cout << a << endl;
}
结果为
1
2
3
4
当a等于5时，跳出循环，不再执行后续的语句体
5. continue语句
语法： continue;
作用：用于跳过当前循环中的某次迭代，直接进入下一次迭代	
示例：
for( int a = 1; a <= 10; a++ )
{
if( a == 5 )
{
continue;
}
cout << a << endl;
}
结果为
1
2
3
4
6
7
8
9
10
当a等于5时，跳过此次迭代，不执行cout语句，直接进入下一次迭代

6. 无限循环
语法：
while( true )
{
语句体；
}
或
for( ; ; )
{
语句体；
}
执行流程：
循环条件永远为true，语句体会一直执行下去，直到程序被强制终止
示例：
while( true )
{
cout << "这是一个无限循环" << endl;
}
或
for( ; ; )
{
cout << "这是一个无限循环" << endl;
}
结果为
这是一个无限循环
这是一个无限循环
这是一个无限循环
...
注意：无限循环会导致程序无法正常结束，建议在语句体中加入break语句或其他跳出循环的条件，防止程序卡死

7. 嵌套循环
语法：
for( 初始化表达式1 ; 条件表达式1 ; 更新表达式1 )
{
for( 初始化表达式2 ; 条件表达式2 ; 更新表达式2 )
{
语句体；
}
}
执行流程：
外层循环控制内层循环的执行次数，内层循环每执行完一次，外层循环就会更新一次
示例：
for( int i = 1; i <= 3; i++ )
{
for( int j = 1; j <= 2; j++ )
{
cout << "i=" << i << ", j=" << j << endl;
}
}
结果为
i=1, j=1
i=1, j=2
i=2, j=1
i=2, j=2
i=3, j=1
i=3, j=2
注意：嵌套循环会增加程序的复杂度，建议在使用时注意代码的可读性和维护性

8.goto语句
语法： goto 标签名;
标签名:
标签名:
作用：用于无条件跳转到程序中的某个位置
示例：
int a = 1;
loop_start:
if( a <= 5 )
{
cout << a << endl;
a++;
goto loop_start;
}
结果为
1
2
3
4
5
注意：goto语句会破坏程序的结构化，建议尽量避免使用，除非在某些特殊情况下，如跳出多层嵌套循环等

*/

//数组
/*
一个数据的集合，放在一块连续的内存空间里，数组中的数据类型相同
1.一维数组
定义方法：数据类型 数组名[数组大小];
		  数据类型 数组名[] = {初始值1, 初始值2, ..., 初始值n}; 省略数组大小，由初始值个数推断
		  数据类型 数组名[数组大小] = {初始值1, 初始值2, ..., 初始值n};
		  注意：数组大小必须是一个常量表达式，不能是变量或浮点数
例如：int arr[5]; 表示定义一个名为arr的整型数组，数组大小为5，该数组中可以存放5个整型数据，索引范围为0~4，即arr[0]~arr[4]
		int arr[] = {1, 2, 3, 4, 5}; 表示定义一个名为arr的整型数组，数组大小为5，该数组中存放了5个整型数据，索引范围为0~4，即arr[0]~arr[4]
		int arr[5] = {1, 2}; 表示定义一个名为arr的整型数组，数组大小为5，该数组中存放了2个初始值，剩余的3个元素会被自动初始化为0，索引范围为0~4，即arr[0]~arr[4]，arr[0]=1, arr[1]=2, arr[2]=0, arr[3]=0, arr[4]=0
		访问数组元素：通过索引访问数组中的某个元素，索引从0开始
		例如：cout << arr[0] << endl; // 输出数组arr的第一个元素
		注意：访问数组元素时，索引不能越界，否则会导致程序异常
		[]中的值叫做下标，表示数组元素在数组中的位置，从0开始计数
		操作数组和操纵变量类似，可以进行赋值、运算等操作
应用示例：
int arr[5] = {1, 2, 3, 4, 5};
for( int i = 0; i < 5; i++ )
{
	cout << arr[i] << " ";
}
结果为 1 2 3 4 5

一维数组名：数组名表示数组的首地址，即数组第一个元素的地址
如：cout << arr << endl; // 输出数组arr的首地址
	cout << &arr[0] << endl; // 输出数组arr第一个元素的地址，结果与上面相同
sizeof(数组名)：表示数组所占的总内存大小
sizeof(数组名[0])：表示数组中每个元素所占的内存大小
sizeof(数组名) / sizeof(数组名[0])：表示数组的元素个数

冒泡排序法：
冒泡排序法是一种简单的排序算法，其基本思想是通过多次比较和交换相邻元素，将较大的元素逐渐“冒泡”到数组的末端，从而实现数组的排序。具体步骤如下：
1. 比较相邻的元素。如果第一个元素比第二个元素大，就交换它们的位置。
2. 对每一对相邻元素重复步骤1，直到数组的最后一个元素。此时，最后一个元素是最大的。
3. 忽略最后一个元素，对剩余的元素重复步骤1和步骤2，直到整个数组有序。
应用示例：
#include <iostream>
using namespace std;
int main()
{
	int arr[] = {5, 2, 9, 1, 5, 6};
	int n = sizeof(arr) / sizeof(arr[0]);
	for( int i = 0; i < n - 1; i++ )          //排序总轮数=数组元素个数-1
	{
		for( int j = 0; j < n - i - 1; j++ )  //每轮比较的次数=数组元素个数-1-排序轮数（第几轮）
		{
			if( arr[j] > arr[j + 1] )
			{
				// 交换 arr[j] 和 arr[j + 1]
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
	cout << "排序后的数组: ";
	for( int i = 0; i < n; i++ )
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	return 0;
}
*/
/*
2.二维数组
定义方法：数据类型 数组名[行数][列数];
		  数据类型 数组名[][列数] = { {初始值1, 初始值2, ..., 初始值n}, {初始值1, 初始值2, ..., 初始值n}, ... }; 省略行数，由初始值个数推断
		  数据类型 数组名[行数][] = { {初始值1, 初始值2, ..., 初始值n}, {初始值1, 初始值2, ..., 初始值n}, ... }; 省略列数，由每行初始值个数推断
		  数据类型 数组名[行数][列数] = { {初始值1, 初始值2, ..., 初始值n}, {初始值1, 初始值2, ..., 初始值n}, ... };
		  数据类型 数组名[行数][列数] = { 初始值1, 初始值2, ..., 初始值n }; 按行优先顺序依次赋值
		  例如：int arr[3][4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }; 表示该数组的12个位置从左到右从上到下依次被赋值为1~12
		  推荐写成：
		  int arr[3][4] = 
		  {
		  {1, 2, 3, 4},
		  {5, 6, 7, 8},
		  {9, 10, 11, 12}
		  };
		  比较直观
		  注意：行数和列数必须是常量表达式，不能是变量或浮点数

		  例如：int arr[3][4]; 表示定义一个名为arr的二维整型数组，数组有3行4列，该数组中可以存放12个整型数据，索引范围为arr[0][0]~arr[2][3]
		  int arr[][4] = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} }; 表示定义一个名为arr的二维整型数组，数组有3行4列，该数组中存放了12个整型数据，索引范围为arr[0][0]~arr[2][3]
		  int arr[3][4] = { {1, 2}, {5, 6, 7}, {9} }; 表示定义一个名为arr的二维整型数组，数组有3行4列，该数组中存放了5个初始值，剩余的元素会被自动初始化为0，
		  索引范围为arr[0][0]~arr[2][3]，arr[0][0]=1, arr[0][1]=2, arr[0][2]=0, arr[0][3]=0, arr[1][0]=5, arr[1][1]=6, arr[1][2]=7, arr[1][3]=0, arr[2][0]=9, arr[2][1]=0, arr[2][2]=0, arr[2][3]=0
		  第一行的四个值中的前两个值被初始化为1和2，后两个值没有被赋值，所以自动初始化为0
		  第二行的四个值中的前三个值被初始化为5、6和7，后一个值没有被赋值，所以自动初始化为0
		  第三行的四个值中的第一个值被初始化为9，后面三个值没有被赋值，所以自动初始化为0

		  访问数组元素：通过行索引和列索引访问数组中的某个元素，索引从0开始
		  例如：cout << arr[0][0] << endl; // 输出数组arr的第一个元素
		  应用示例：
		  int arr[3][4] = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} };
		  for( int i = 0; i < 3; i++ )
		  {
			  for( int j = 0; j < 4; j++ )
			  {
				  cout << arr[i][j] << " ";
			  }
			  cout << endl;
		  }
		  结果为
		  1 2 3 4
		  5 6 7 8
		  9 10 11 12
二维数组名：数组名表示数组的首地址，即数组第一个元素的地址
如：cout << arr << endl; // 输出数组arr的首地址
	cout << &arr[0][0] << endl; // 输出数组arr第一个元素的地址，结果与上面相同
	cout << arr[0] << endl; // 输出数组arr第一行的首地址
	cout << arr[1] << endl; // 输出数组arr第二行的首地址
	sizeof(数组名)：                             表示数组所占的总内存大小
	sizeof(数组名[0])：                          表示数组中每行所占的内存大小
	sizeof(数组名[0][0])：                       表示数组中每个元素所占的内存大小
	sizeof(数组名) / sizeof(数组名[0][0])：      表示数组的元素个数
	sizeof(数组名) / sizeof(数组名[0])：         表示数组的行数
	sizeof(数组名[0]) / sizeof(数组名[0][0])：   表示数组的列数
*/

*/